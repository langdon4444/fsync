#!/usr/bin/env python
import sys, os
import zmq
from zmq import ssh
import subprocess
import json
import time

PORT = 12345
SERVER_ROOT = '/tmp'

def myname():
    import socket
    return socket.gethostname()

def normalize_path(path):
    return os.path.relpath(os.path.abspath(path), os.environ['HOME'])

try:
    ssh_string = os.environ['SSH_CLIENT']
    hostip = ssh_string.split()[0]
except KeyError:
    raise RuntimeError('Could not find SSH CLIENT')
    

def main(bin, file):
    nfile = normalize_path(file)
    if not os.path.exists(file):
        # if the file doesn't exist, touch it
        open(file, 'w').close()
    if '..' in nfile:
        raise ValueError('Sorry, %s is not in the home directory' % file)
    
    context = zmq.Context.instance()
    sock = context.socket(zmq.REQ)
    ssh.tunnel_connection(sock, "tcp://localhost:%d" % PORT, hostip)

    server_fn = os.path.join(SERVER_ROOT, myname(), nfile)
    if os.path.isdir(server_fn):
        server_fn += '/'

    #rsync the file to the server
    def do_rsync():
        cmd = ['/usr/bin/rsync', '-r', file, hostip + ':' + server_fn]
        subprocess.check_output(' '.join(cmd), shell=True, stderr=subprocess.STDOUT)
    try:
        do_rsync()
    except subprocess.CalledProcessError:
        # tell the server to do the mkdir operator that rsync doesn't want to do
        sock.send('#MKDIR#')
        assert sock.recv() == '#GO#'
        sock.send(os.path.dirname(server_fn))
        assert sock.recv() == '#DONE#'
        do_rsync()

    #alert the server that we've sent it the file
    sock.send('#FILE#')
    assert sock.recv() == '#GO#'
    sock.send(json.dumps({'server_fn': server_fn, 'hostname': myname(),
                          'client_fn': os.path.abspath(file)}))
    assert sock.recv() == '#DONE#'

    
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print 'Usage: %s <directory>' % sys.arv[0]

    main('mate', sys.argv[1])
